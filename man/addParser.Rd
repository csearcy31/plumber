% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parse-body.R
\name{addParser}
\alias{addParser}
\title{Add a Parsers}
\usage{
addParser(name, parser, pattern = NULL)
}
\arguments{
\item{name}{The name of the parser (character string)}

\item{parser}{The parser to be added.}

\item{pattern}{A pattern to match against the content-type of each part of
the request body.}
}
\description{
A parser is responsible for decoding the raw body content of a request into
a list of arguments that can be mapped to endpoint function arguments.
For instance, the \code{parser_json} parser content-type \code{application/json}.
The list of available parsers in plumber is global.
}
\details{
For instance, the \code{parser_json} pattern is \code{application/json}.
If \code{pattern} is not provided, will be set to \code{application/{name}}.
Detection is done assuming content-type starts with pattern and is
case sensitive.

Parser function structure is something like below. Available parameters
to build parser are \code{value}, \code{content_type} and \code{filename} (only available
in \code{multipart-form} body).\if{html}{\out{<div class="r">}}\preformatted{parser <- function() \{
  function(value, content_type = "ct", filename, ...) \{
    # do something with raw value
  \}
\}
}\if{html}{\out{</div>}}

It should return a named list if you want values to map to
plumber endpoint function args.
}
\examples{
parser_json <- function() {
  function(value, content_type = "application/json", ...) {
    charset <- getCharacterSet(content_type)
    value <- rawToChar(value)
    Encoding(value) <- charset
    jsonlite::fromJSON(value)
  }
}
}
